"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f7e5a58a67af\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaHBcXE9uZURyaXZlXFxEZXNrdG9wXFxCbG9nTWluZC1BcHBcXGJsb2ctbWluZC1mcm9udGVuZFxcYXBwXFxnbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImY3ZTVhNThhNjdhZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/api-client.ts":
/*!***************************!*\
  !*** ./lib/api-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyticsApi: () => (/* binding */ analyticsApi),\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   authApi: () => (/* binding */ authApi),\n/* harmony export */   blogApi: () => (/* binding */ blogApi),\n/* harmony export */   commentApi: () => (/* binding */ commentApi),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   uploadApi: () => (/* binding */ uploadApi)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\n// Set the base API URL from environment variables\nconst API_URL = \"https://blogmind-app-1.onrender.com\";\n// Function to check if the server is reachable\nasync function checkServerStatus() {\n    try {\n        const response = await fetch(\"\".concat(API_URL, \"/\"), {\n            method: \"GET\"\n        });\n        if (!response.ok) throw new Error(\"Server not reachable\");\n    } catch (error) {\n        document.body.innerHTML = '\\n      <div style=\"text-align: center; padding: 20px;\">\\n        <h1 style=\"color: red;\">Server is Down</h1>\\n        <p>Please try again later.</p>\\n      </div>\\n    ';\n        throw new Error(\"Server is down\");\n    }\n}\n// Check the server before making requests\ncheckServerStatus();\nconst apiClient = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_URL,\n    headers: {\n        \"Content-Type\": \"application/json\"\n    }\n});\n// Add request interceptor to include auth token\napiClient.interceptors.request.use((config)=>{\n    if (true) {\n        const token = localStorage.getItem(\"token\");\n        if (token) {\n            config.headers.Authorization = \"Bearer \".concat(token);\n        }\n    }\n    return config;\n}, (error)=>Promise.reject(error));\n// Auth-specific API functions\nconst authApi = {\n    // Register a new user\n    register: async (userData)=>{\n        const response = await apiClient.post(\"/api/auth/register\", userData);\n        return response.data;\n    },\n    // Login with email and password\n    login: async (email, password)=>{\n        const formData = new URLSearchParams();\n        formData.append(\"username\", email) // OAuth2 uses \"username\" for email\n        ;\n        formData.append(\"password\", password);\n        try {\n            const response = await apiClient.post(\"/api/auth/login\", formData, {\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n            const data = response.data;\n            localStorage.setItem(\"token\", data.access_token) // Store token\n            ;\n            return data;\n        } catch (error) {\n            var _error_response;\n            console.error(\"Login Failed:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n            throw error;\n        }\n    },\n    // Get current user profile\n    getCurrentUser: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/users/me\");\n            return response.data;\n        } catch (error) {\n            var _error_response;\n            console.error(\"Error fetching user:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n            throw error;\n        }\n    },\n    // Update user profile\n    updateUser: async (userData)=>{\n        try {\n            const response = await apiClient.put(\"/api/users/me\", userData);\n            return response.data;\n        } catch (error) {\n            var _error_response;\n            console.error(\"Profile update failed:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n            throw error;\n        }\n    }\n};\n// Blog API functions\nconst blogApi = {\n    // Get all blogs with optional filtering\n    getBlogs: async (params)=>{\n        try {\n            const response = await apiClient.get(\"/api/blogs\", {\n                params\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch blogs:\", error);\n            throw error;\n        }\n    },\n    // Get a blog by slug\n    getBlogBySlug: async (slug)=>{\n        try {\n            const response = await apiClient.get(\"/api/blogs/\".concat(slug));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch blog:\", error);\n            throw error;\n        }\n    },\n    // Create a new blog\n    createBlog: async (blogData)=>{\n        try {\n            const response = await apiClient.post(\"/api/blogs\", blogData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to create blog:\", error);\n            throw error;\n        }\n    },\n    // Update a blog\n    updateBlog: async (blogId, blogData)=>{\n        try {\n            const response = await apiClient.put(\"/api/blogs/\".concat(blogId), blogData);\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to update blog:\", error);\n            throw error;\n        }\n    },\n    // Delete a blog\n    deleteBlog: async (blogId)=>{\n        try {\n            await apiClient.delete(\"/api/blogs/\".concat(blogId));\n            return true;\n        } catch (error) {\n            console.error(\"Failed to delete blog:\", error);\n            throw error;\n        }\n    },\n    // Like or unlike a blog\n    likeBlog: async (slug)=>{\n        try {\n            const response = await apiClient.post(\"/api/blogs/\".concat(slug, \"/like\"));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to like/unlike blog:\", error);\n            throw error;\n        }\n    },\n    // Get all categories\n    getCategories: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/blogs/categories\");\n            //console.log(\"The categories are:\", response.data) // Remove this line only for testing\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch categories:\", error);\n            throw error;\n        }\n    },\n    // Get user's blogs\n    getUserBlogs: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/users/blogs\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch user blogs:\", error);\n            throw error;\n        }\n    },\n    // Get user's liked blogs\n    getLikedBlogs: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/users/liked\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch liked blogs:\", error);\n            throw error;\n        }\n    }\n};\n// Comment API functions\nconst commentApi = {\n    // Get comments for a blog\n    getComments: async (blogId)=>{\n        try {\n            const response = await apiClient.get(\"/api/comments/blog/\".concat(blogId));\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch comments:\", error);\n            throw error;\n        }\n    },\n    // Add a comment to a blog\n    addComment: async (blogId, content)=>{\n        try {\n            const response = await apiClient.post(\"/api/comments\", {\n                blog_id: blogId,\n                content\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to add comment:\", error);\n            throw error;\n        }\n    },\n    // Update a comment\n    updateComment: async (commentId, content)=>{\n        try {\n            const response = await apiClient.put(\"/api/comments/\".concat(commentId), {\n                content\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to update comment:\", error);\n            throw error;\n        }\n    },\n    // Delete a comment\n    deleteComment: async (commentId)=>{\n        try {\n            await apiClient.delete(\"/api/comments/\".concat(commentId));\n            return true;\n        } catch (error) {\n            console.error(\"Failed to delete comment:\", error);\n            throw error;\n        }\n    },\n    // Get user's comments\n    getUserComments: async ()=>{\n        try {\n            const response = await apiClient.get(\"/api/users/comments\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch user comments:\", error);\n            throw error;\n        }\n    }\n};\n// Upload API functions\nconst uploadApi = {\n    // Upload avatar\n    uploadAvatar: async (file)=>{\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const response = await apiClient.post(\"/api/uploads/avatar\", formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                }\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to upload avatar:\", error);\n            throw error;\n        }\n    },\n    // Upload blog image\n    uploadBlogImage: async (file)=>{\n        try {\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            const response = await apiClient.post(\"/api/uploads/blog-image\", formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                }\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to upload blog image:\", error);\n            throw error;\n        }\n    }\n};\n// Analytics API functions\nconst analyticsApi = {\n    // Record blog view\n    recordBlogView: async (slug, referrer)=>{\n        try {\n            await apiClient.post(\"/api/analytics/view/\".concat(slug), {\n                referrer\n            });\n            return true;\n        } catch (error) {\n            console.error(\"Failed to record view:\", error);\n            return false;\n        }\n    },\n    // Record read progress\n    recordReadProgress: async (slug, readPercentage)=>{\n        if (!slug || typeof readPercentage !== \"number\" || readPercentage < 0 || readPercentage > 100) {\n            console.error(\"Invalid read progress data\");\n            return false;\n        }\n        try {\n            const response = await apiClient.post(\"/api/analytics/read-progress/\".concat(slug), {\n                read_percentage: readPercentage\n            });\n            return response.data;\n        } catch (error) {\n            var _error_response;\n            console.error(\"Failed to record read progress:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n            return false;\n        }\n    },\n    // Get blog analytics\n    getBlogAnalytics: async function(slug) {\n        let days = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 30;\n        try {\n            const response = await apiClient.get(\"/api/analytics/blog/\".concat(slug), {\n                params: {\n                    days\n                }\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch blog analytics:\", error);\n            throw error;\n        }\n    },\n    // Get user analytics\n    getUserAnalytics: async function() {\n        let days = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        try {\n            const response = await apiClient.get(\"/api/analytics/user\", {\n                params: {\n                    days\n                }\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to fetch user analytics:\", error);\n            throw error;\n        }\n    }\n};\nconst api = {\n    likeBlog: blogApi.likeBlog,\n    getUserAnalytics: analyticsApi.getUserAnalytics\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (apiClient);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0M7Z0JBQUs7WUFDakI7WUFDQSxPQUFPOUUsU0FBUzJCLElBQUk7UUFDdEIsRUFBRSxPQUFPdEIsT0FBTztZQUNkK0IsUUFBUS9CLEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ2pELE1BQU1BO1FBQ1I7SUFDRjtBQUNGLEVBQUM7QUFFTSxNQUFNMkUsTUFBTTtJQUNqQjNCLFVBQVVYLFFBQVFXLFFBQVE7SUFDMUIwQixrQkFBa0JSLGFBQWFRLGdCQUFnQjtBQUNqRCxFQUFDO0FBRUQsaUVBQWV0RSxTQUFTQSxFQUFBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGhwXFxPbmVEcml2ZVxcRGVza3RvcFxcQmxvZ01pbmQtQXBwXFxibG9nLW1pbmQtZnJvbnRlbmRcXGxpYlxcYXBpLWNsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCJcblxuLy8gU2V0IHRoZSBiYXNlIEFQSSBVUkwgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMXG5cbi8vIEZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBzZXJ2ZXIgaXMgcmVhY2hhYmxlXG5hc3luYyBmdW5jdGlvbiBjaGVja1NlcnZlclN0YXR1cygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9L2AsIHsgbWV0aG9kOiBcIkdFVFwiIH0pO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihcIlNlcnZlciBub3QgcmVhY2hhYmxlXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID0gYFxuICAgICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjsgcGFkZGluZzogMjBweDtcIj5cbiAgICAgICAgPGgxIHN0eWxlPVwiY29sb3I6IHJlZDtcIj5TZXJ2ZXIgaXMgRG93bjwvaDE+XG4gICAgICAgIDxwPlBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuPC9wPlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2ZXIgaXMgZG93blwiKTtcbiAgfVxufVxuXG4vLyBDaGVjayB0aGUgc2VydmVyIGJlZm9yZSBtYWtpbmcgcmVxdWVzdHNcbmNoZWNrU2VydmVyU3RhdHVzKCk7XG5cbmNvbnN0IGFwaUNsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IEFQSV9VUkwsXG4gIGhlYWRlcnM6IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgfSxcbn0pXG5cbi8vIEFkZCByZXF1ZXN0IGludGVyY2VwdG9yIHRvIGluY2x1ZGUgYXV0aCB0b2tlblxuYXBpQ2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcbiAgKGNvbmZpZykgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5cIilcbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9LFxuICAoZXJyb3IpID0+IFByb21pc2UucmVqZWN0KGVycm9yKSxcbilcblxuLy8gQXV0aC1zcGVjaWZpYyBBUEkgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgYXV0aEFwaSA9IHtcbiAgLy8gUmVnaXN0ZXIgYSBuZXcgdXNlclxuICByZWdpc3RlcjogYXN5bmMgKHVzZXJEYXRhOiB7XG4gICAgZW1haWw6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHBhc3N3b3JkOiBzdHJpbmdcbiAgICBiaW8/OiBzdHJpbmdcbiAgICBhdmF0YXI/OiBzdHJpbmdcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoXCIvYXBpL2F1dGgvcmVnaXN0ZXJcIiwgdXNlckRhdGEpXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgfSxcblxuICAvLyBMb2dpbiB3aXRoIGVtYWlsIGFuZCBwYXNzd29yZFxuICBsb2dpbjogYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICAgIGZvcm1EYXRhLmFwcGVuZChcInVzZXJuYW1lXCIsIGVtYWlsKSAvLyBPQXV0aDIgdXNlcyBcInVzZXJuYW1lXCIgZm9yIGVtYWlsXG4gICAgZm9ybURhdGEuYXBwZW5kKFwicGFzc3dvcmRcIiwgcGFzc3dvcmQpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChcIi9hcGkvYXV0aC9sb2dpblwiLCBmb3JtRGF0YSwge1xuICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgfSxcbiAgICAgIH0pXG4gICAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YVxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ0b2tlblwiLCBkYXRhLmFjY2Vzc190b2tlbikgLy8gU3RvcmUgdG9rZW5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkxvZ2luIEZhaWxlZDpcIiwgZXJyb3IucmVzcG9uc2U/LmRhdGEgfHwgZXJyb3IubWVzc2FnZSlcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCBjdXJyZW50IHVzZXIgcHJvZmlsZVxuICBnZXRDdXJyZW50VXNlcjogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoXCIvYXBpL3VzZXJzL21lXCIpXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyB1c2VyOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gVXBkYXRlIHVzZXIgcHJvZmlsZVxuICB1cGRhdGVVc2VyOiBhc3luYyAodXNlckRhdGE6IHtcbiAgICBuYW1lPzogc3RyaW5nXG4gICAgZW1haWw/OiBzdHJpbmdcbiAgICBiaW8/OiBzdHJpbmdcbiAgICBhdmF0YXI/OiBzdHJpbmdcbiAgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoXCIvYXBpL3VzZXJzL21lXCIsIHVzZXJEYXRhKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUHJvZmlsZSB1cGRhdGUgZmFpbGVkOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG59XG5cbi8vIEJsb2cgQVBJIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGJsb2dBcGkgPSB7XG4gIC8vIEdldCBhbGwgYmxvZ3Mgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmdcbiAgZ2V0QmxvZ3M6IGFzeW5jIChwYXJhbXM6IHtcbiAgICBzZWFyY2g/OiBzdHJpbmdcbiAgICBjYXRlZ29yeT86IHN0cmluZ1xuICAgIHRhZz86IHN0cmluZ1xuICAgIHNvcnQ/OiBzdHJpbmdcbiAgICBza2lwPzogbnVtYmVyXG4gICAgbGltaXQ/OiBudW1iZXJcbiAgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoXCIvYXBpL2Jsb2dzXCIsIHsgcGFyYW1zIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGJsb2dzOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCBhIGJsb2cgYnkgc2x1Z1xuICBnZXRCbG9nQnlTbHVnOiBhc3luYyAoc2x1Zzogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChgL2FwaS9ibG9ncy8ke3NsdWd9YClcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggYmxvZzpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBDcmVhdGUgYSBuZXcgYmxvZ1xuICBjcmVhdGVCbG9nOiBhc3luYyAoYmxvZ0RhdGE6IHtcbiAgICB0aXRsZTogc3RyaW5nXG4gICAgY29udGVudDogc3RyaW5nXG4gICAgZXhjZXJwdDogc3RyaW5nXG4gICAgY2F0ZWdvcnlfaWQ6IHN0cmluZ1xuICAgIHRhZ3M6IHN0cmluZ1tdXG4gICAgY292ZXJfaW1hZ2U/OiBzdHJpbmdcbiAgICBwdWJsaXNoZWQ/OiBib29sZWFuXG4gIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgXG5cblxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KFwiL2FwaS9ibG9nc1wiLCBibG9nRGF0YSlcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGJsb2c6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gVXBkYXRlIGEgYmxvZ1xuICB1cGRhdGVCbG9nOiBhc3luYyAoXG4gICAgYmxvZ0lkOiBzdHJpbmcsXG4gICAgYmxvZ0RhdGE6IHtcbiAgICAgIHRpdGxlPzogc3RyaW5nXG4gICAgICBjb250ZW50Pzogc3RyaW5nXG4gICAgICBleGNlcnB0Pzogc3RyaW5nXG4gICAgICBjYXRlZ29yeV9pZD86IHN0cmluZ1xuICAgICAgdGFncz86IHN0cmluZ1tdXG4gICAgICBjb3Zlcl9pbWFnZT86IHN0cmluZ1xuICAgICAgcHVibGlzaGVkPzogYm9vbGVhblxuICAgIH0sXG4gICkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wdXQoYC9hcGkvYmxvZ3MvJHtibG9nSWR9YCwgYmxvZ0RhdGEpXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBibG9nOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIERlbGV0ZSBhIGJsb2dcbiAgZGVsZXRlQmxvZzogYXN5bmMgKGJsb2dJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvYmxvZ3MvJHtibG9nSWR9YClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIGJsb2c6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gTGlrZSBvciB1bmxpa2UgYSBibG9nXG4gIGxpa2VCbG9nOiBhc3luYyAoc2x1Zzogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnBvc3QoYC9hcGkvYmxvZ3MvJHtzbHVnfS9saWtlYClcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbGlrZS91bmxpa2UgYmxvZzpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgYWxsIGNhdGVnb3JpZXNcbiAgZ2V0Q2F0ZWdvcmllczogYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoXCIvYXBpL2Jsb2dzL2NhdGVnb3JpZXNcIilcbiAgICAgIC8vY29uc29sZS5sb2coXCJUaGUgY2F0ZWdvcmllcyBhcmU6XCIsIHJlc3BvbnNlLmRhdGEpIC8vIFJlbW92ZSB0aGlzIGxpbmUgb25seSBmb3IgdGVzdGluZ1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBjYXRlZ29yaWVzOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCB1c2VyJ3MgYmxvZ3NcbiAgZ2V0VXNlckJsb2dzOiBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChcIi9hcGkvdXNlcnMvYmxvZ3NcIilcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdXNlciBibG9nczpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBHZXQgdXNlcidzIGxpa2VkIGJsb2dzXG4gIGdldExpa2VkQmxvZ3M6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KFwiL2FwaS91c2Vycy9saWtlZFwiKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBsaWtlZCBibG9nczpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ29tbWVudCBBUEkgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgY29tbWVudEFwaSA9IHtcbiAgLy8gR2V0IGNvbW1lbnRzIGZvciBhIGJsb2dcbiAgZ2V0Q29tbWVudHM6IGFzeW5jIChibG9nSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvY29tbWVudHMvYmxvZy8ke2Jsb2dJZH1gKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBjb21tZW50czpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBBZGQgYSBjb21tZW50IHRvIGEgYmxvZ1xuICBhZGRDb21tZW50OiBhc3luYyAoYmxvZ0lkOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KFwiL2FwaS9jb21tZW50c1wiLCB7XG4gICAgICAgIGJsb2dfaWQ6IGJsb2dJZCxcbiAgICAgICAgY29udGVudCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGFkZCBjb21tZW50OlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIFVwZGF0ZSBhIGNvbW1lbnRcbiAgdXBkYXRlQ29tbWVudDogYXN5bmMgKGNvbW1lbnRJZDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucHV0KGAvYXBpL2NvbW1lbnRzLyR7Y29tbWVudElkfWAsIHtcbiAgICAgICAgY29udGVudCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBjb21tZW50OlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIERlbGV0ZSBhIGNvbW1lbnRcbiAgZGVsZXRlQ29tbWVudDogYXN5bmMgKGNvbW1lbnRJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGFwaUNsaWVudC5kZWxldGUoYC9hcGkvY29tbWVudHMvJHtjb21tZW50SWR9YClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVsZXRlIGNvbW1lbnQ6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgLy8gR2V0IHVzZXIncyBjb21tZW50c1xuICBnZXRVc2VyQ29tbWVudHM6IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQuZ2V0KFwiL2FwaS91c2Vycy9jb21tZW50c1wiKVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCB1c2VyIGNvbW1lbnRzOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxufVxuXG4vLyBVcGxvYWQgQVBJIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IHVwbG9hZEFwaSA9IHtcbiAgLy8gVXBsb2FkIGF2YXRhclxuICB1cGxvYWRBdmF0YXI6IGFzeW5jIChmaWxlOiBGaWxlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSlcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChcIi9hcGkvdXBsb2Fkcy9hdmF0YXJcIiwgZm9ybURhdGEsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gdXBsb2FkIGF2YXRhcjpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfSxcblxuICAvLyBVcGxvYWQgYmxvZyBpbWFnZVxuICB1cGxvYWRCbG9nSW1hZ2U6IGFzeW5jIChmaWxlOiBGaWxlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKClcbiAgICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSlcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucG9zdChcIi9hcGkvdXBsb2Fkcy9ibG9nLWltYWdlXCIsIGZvcm1EYXRhLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwbG9hZCBibG9nIGltYWdlOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxufVxuXG4vLyBBbmFseXRpY3MgQVBJIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGFuYWx5dGljc0FwaSA9IHtcbiAgLy8gUmVjb3JkIGJsb2cgdmlld1xuICByZWNvcmRCbG9nVmlldzogYXN5bmMgKHNsdWc6IHN0cmluZywgcmVmZXJyZXI/OiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgYXBpQ2xpZW50LnBvc3QoYC9hcGkvYW5hbHl0aWNzL3ZpZXcvJHtzbHVnfWAsIHsgcmVmZXJyZXIgfSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcmVjb3JkIHZpZXc6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlY29yZCByZWFkIHByb2dyZXNzXG4gIHJlY29yZFJlYWRQcm9ncmVzczogYXN5bmMgKHNsdWc6IHN0cmluZywgcmVhZFBlcmNlbnRhZ2U6IG51bWJlcikgPT4ge1xuICAgIGlmICghc2x1ZyB8fCB0eXBlb2YgcmVhZFBlcmNlbnRhZ2UgIT09IFwibnVtYmVyXCIgfHwgcmVhZFBlcmNlbnRhZ2UgPCAwIHx8IHJlYWRQZXJjZW50YWdlID4gMTAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIHJlYWQgcHJvZ3Jlc3MgZGF0YVwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5wb3N0KGAvYXBpL2FuYWx5dGljcy9yZWFkLXByb2dyZXNzLyR7c2x1Z31gLCB7XG4gICAgICAgICAgICByZWFkX3BlcmNlbnRhZ2U6IHJlYWRQZXJjZW50YWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlY29yZCByZWFkIHByb2dyZXNzOlwiLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sXG5cbiAgLy8gR2V0IGJsb2cgYW5hbHl0aWNzXG4gIGdldEJsb2dBbmFseXRpY3M6IGFzeW5jIChzbHVnOiBzdHJpbmcsIGRheXMgPSAzMCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXQoYC9hcGkvYW5hbHl0aWNzL2Jsb2cvJHtzbHVnfWAsIHtcbiAgICAgICAgcGFyYW1zOiB7IGRheXMgfSxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGJsb2cgYW5hbHl0aWNzOlwiLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9LFxuXG4gIC8vIEdldCB1c2VyIGFuYWx5dGljc1xuICBnZXRVc2VyQW5hbHl0aWNzOiBhc3luYyAoZGF5cyA9IDMwKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmdldChcIi9hcGkvYW5hbHl0aWNzL3VzZXJcIiwge1xuICAgICAgICBwYXJhbXM6IHsgZGF5cyB9LFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggdXNlciBhbmFseXRpY3M6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBhcGkgPSB7XG4gIGxpa2VCbG9nOiBibG9nQXBpLmxpa2VCbG9nLFxuICBnZXRVc2VyQW5hbHl0aWNzOiBhbmFseXRpY3NBcGkuZ2V0VXNlckFuYWx5dGljcyxcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBpQ2xpZW50XG5cbiJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImNoZWNrU2VydmVyU3RhdHVzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsIm9rIiwiRXJyb3IiLCJlcnJvciIsImRvY3VtZW50IiwiYm9keSIsImlubmVySFRNTCIsImFwaUNsaWVudCIsImNyZWF0ZSIsImJhc2VVUkwiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkF1dGhvcml6YXRpb24iLCJQcm9taXNlIiwicmVqZWN0IiwiYXV0aEFwaSIsInJlZ2lzdGVyIiwidXNlckRhdGEiLCJwb3N0IiwiZGF0YSIsImxvZ2luIiwiZW1haWwiLCJwYXNzd29yZCIsImZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwic2V0SXRlbSIsImFjY2Vzc190b2tlbiIsImNvbnNvbGUiLCJtZXNzYWdlIiwiZ2V0Q3VycmVudFVzZXIiLCJnZXQiLCJ1cGRhdGVVc2VyIiwicHV0IiwiYmxvZ0FwaSIsImdldEJsb2dzIiwicGFyYW1zIiwiZ2V0QmxvZ0J5U2x1ZyIsInNsdWciLCJjcmVhdGVCbG9nIiwiYmxvZ0RhdGEiLCJ1cGRhdGVCbG9nIiwiYmxvZ0lkIiwiZGVsZXRlQmxvZyIsImRlbGV0ZSIsImxpa2VCbG9nIiwiZ2V0Q2F0ZWdvcmllcyIsImdldFVzZXJCbG9ncyIsImdldExpa2VkQmxvZ3MiLCJjb21tZW50QXBpIiwiZ2V0Q29tbWVudHMiLCJhZGRDb21tZW50IiwiY29udGVudCIsImJsb2dfaWQiLCJ1cGRhdGVDb21tZW50IiwiY29tbWVudElkIiwiZGVsZXRlQ29tbWVudCIsImdldFVzZXJDb21tZW50cyIsInVwbG9hZEFwaSIsInVwbG9hZEF2YXRhciIsImZpbGUiLCJGb3JtRGF0YSIsInVwbG9hZEJsb2dJbWFnZSIsImFuYWx5dGljc0FwaSIsInJlY29yZEJsb2dWaWV3IiwicmVmZXJyZXIiLCJyZWNvcmRSZWFkUHJvZ3Jlc3MiLCJyZWFkUGVyY2VudGFnZSIsInJlYWRfcGVyY2VudGFnZSIsImdldEJsb2dBbmFseXRpY3MiLCJkYXlzIiwiZ2V0VXNlckFuYWx5dGljcyIsImFwaSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-client.ts\n"));

/***/ })

});